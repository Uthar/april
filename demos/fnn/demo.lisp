;;; -*- Mode:Lisp; Syntax:ANSI-Common-Lisp; Coding:utf-8; Package:AprilDemo.Fnn -*-
;;;; demo.lisp

(in-package #:april-demo.fnn)

"Implement a basic forward-feeding neural network. This demo network is trained and tested against the popular MNIST database of handwritten digits."

(defparameter *package-symbol* (intern (package-name *package*) "KEYWORD"))

;; import the display function from the April's array standard library
(april (with (:space fnn-demo-space))
       "display ← 'ARRAY-LIB-SPACE' ⎕XWF 'display'")

#|
-- Function --
Normal Array Construction

This function generates arrays containing a normal distribution of randomly chosen floating point numbers.
|#

(april (with (:space fnn-demo-space))
       "
MakeNormalArray ← {
  U1 ← ?⍵⍴0
  U2 ← ?⍵⍴0
  s  ← (¯2×⍟U1)*÷2
  c  ← 2○2×○U2
  c×s
}
")

#|
∘○ To Verify ○∘
Normally Distributed Array Elements

Evaluate (verify-normal-array) to see an array of normally-distributed floating point numbers. Optionally, pass a shape like #(2 3 4) to this function to receive an array of the corresponding shape.

Evaluate (verify-normal-distrib) to see a vector representing the distribution of values generated by MakeNormalArray.

Evaluate (verify-plot-normal-distrib) to see a plot of the value distribution generated by MakeNormalArray. Try smaller counts as with (verify-plot-normal-vector 100) to see a less normal distribution and larger counts like 10,000 to see a more normal distribution. You may pass a width value as the second argument to control the width of the plot, i.e. (verify-plot-normal-vector :count 1000 :width 40) will produce a plot whose rows may be no longer than 40 characters.
|#

(defun verify-normal-array (&optional (shape 10))
  "Generate an array of normally-distributed floating point numbers."
  (april-c (with (:space fnn-demo-space)) "MakeNormalArray" shape))

(defun verify-normal-distrib (&optional (count 1000))
  "Generate a vector of integers reflecting the distribution of floating point numbers in an array produced by MakeNormalArray."
  (april-c (with (:space fnn-demo-space))
           "{{{¯1+≢⍵}⌸⍵,⍨⍳21}⊢⊢(2.0÷⍨¯11+⍳21)⍸MakeNormalArray ⍵}"
           count))

(defun verify-plot-normal-distrib (&key (count 1000) (width 80))
  "Plot the distribution of numbers generated using MakeNormalArray."
  (april-c (with (:space fnn-demo-space))
           "{⍺{⎕←↑'⎕'⍴¨⍨⌊⍺×⍵÷⌈/⍵}{{¯1+≢⍵}⌸⍵,⍨⍳21}⊢⊢(2.0÷⍨¯11+⍳21)⍸MakeNormalArray ⍵ ⋄ 'Plotted.'}"
           count width))

#|
-- Functions --
Network Construction

These functions are used to build neural networks.
|#

(april (with (:space fnn-demo-space))
       "
InitNetwork ← {
  ⍝ ⍵ is the shape of the network.
  ⍝ Returns a pair of weight matrices and bias vectors.
  (InitWeightMatrices ⍵) (InitBiasVectors ⍵)
}

InitBiasVectors ← {
  ⍝ ⍵ is the shape of the network.
  ⍝ Returns a vector of bias vectors.
  shape ← 1↓⍵
  (shape*0.5) ÷⍨ ⍪∘MakeNormalArray¨ shape
}

InitWeightMatrices ← {
  ⍝ ⍵ is the shape of the network.
  ⍝ Returns a vector of weight matrices.
  matrices ← MakeNormalArray¨ 2 ,⍨/⍵
  matrices ÷ 0.5*⍨2×/⍵
}
")

#|
∘○ To Verify ○∘
Neural Network Structure

Evaluate (verify-network-structure) to see the printed structure of a random neural network. Optionally, choose a shape for the network by passing a vector of dimensions to the function, as with (verify-network-structure #(2 5 3)).
|#

(defun verify-network-structure (&optional (shape #(3 6 2)))
  "Display the structure of a neural network with an optionally specified shape."
  (april-c (with (:space fnn-demo-space))
           "{⎕←display InitNetwork ⍵ ⋄ 'Neural network structure.'}"
           shape))

#|
-- Function --
Forward Pass

This function derives output from a neural network based on input data and the weights assigned to the neurons.
|#

(april (with (:space fnn-demo-space))
       "
_ForwardPass ← {
  ⍝ ⍺⍺ is the activation function
  ⍝ ⍺ is the network
  ⍝ ⍵ is the network input
  (ws  bs) ← ⍺
  (_ _ xs) ← (⍺⍺ _F⍣(≢ws)) ws bs (⊂⍵)
  xs
}

_F ← {
  ⍝ ⍺⍺ is the activation function.
  ⍝ (ws bs xs) ← ⍵ are the components for the calculations.
  (ws bs xs) ← ⍵
  w   ← ⊃ ws
  b   ← ⊃ bs
  inp ← ⊃⌽xs
  x   ← ⍺⍺ b+w+.×inp
  (1↓ws) (1↓bs) (xs,⊂x)
}
")

#|
-- Function --
Output Activation

This function is used to postprocess the output of each layer of the neural network before it is passed to the next layer. It is assigned to a namespace containing its derivative as well as the "leaky parameter" determining the 
|#

(april (with (:space fnn-demo-space))
       "
LeakyReLU ← ⎕NS⍬

⎕CS LeakyReLU

leaky ← 0.1

F  ← {
  ⍝ ⍵ is the argument of the function.
  ⍵⌈leaky×⍵
}

DF ← {
  ⍝ ⍵ is the argument of the function.
  leaky⌈×⍵
}

⎕CS _
")

#|
∘○ To Verify ○∘
Activation and Neural Network Output

Evaluate (verify-activation-output) to see the output of the LeakyReLU function with an optional input value and its standard leaky parameter of 0.1. Evaluate (verify-network-output) to see the printed output of a random neural network. As with (verify-network-structure), you can optionally choose a shape for the input network.
|#

(defun verify-activation-output (&optional (input #(1.0d0 -2.0d0 3.0d0 -4.0d0)))
  (april-c (with (:space fnn-demo-space)) "LeakyReLU.F" input))

(defun verify-network-output (&optional (shape #(3 6 2)))
  "Display the output of a forward pass through a neural network."
  (april-c (with (:space fnn-demo-space))
           "{⎕←display (InitNetwork ⍵) (LeakyReLU.F _ForwardPass) ⍪1 0 0 ⋄ 'Neural network output.'}"
           shape))

#|
-- Function --
Loss Determination

This function is used to determine the quality of the network's output. It is assigned within a namespace alongside its derivative.
|#

(april (with (:space fnn-demo-space))
       "
MSELoss ← ⎕NS⍬

⎕CS MSELoss

F  ← {
  ⍝ Mean Squared Error loss function.
  ⍝ Find the errors, square them and average them.
  ⍝ ⍵ is the network output.
  ⍝ ⍺ is the correct target.
  sq ← 2*⍨⍵-⍺
  (≢sq) ÷⍨ +/,sq
}

DF ← {
  ⍝ Derivative of the MSELoss function.
  ⍝ ⍵ is the network output.
  ⍝ ⍺ is the correct target.
  (≢⍵)÷⍨2×⍵-⍺
}

⎕CS _
")

#|
∘○ To Verify ○∘
Loss Function and Its Derivative

Evaluate (verify-loss-convergence) to see a vector of the output from the derivative loss function with a given input and the output of the algorithmically derived loss function given the same input and a given dx value. For example, you can run (verify-loss-convergence :input 5 :dx 0.1)  To see the same with a series of dx values, evaluate (verify-loss-convergence-series), optionally with input as with (verify-loss-convergence-series :input 5 :series #(0.1d0 0.01d0 0.001d0)).

The (verify-network-output-loss)
|#

(defun verify-loss-convergence (&key (input 3) (dx 0.1))
  "Show the derivative of the MSELoss function and the convergence of a value given its integral for an optionally specified input and dx value."
  (april-c (with (:space fnn-demo-space))
           "{
_D ← {⍺÷⍨(⍺⍺ ⍵+⍺)-⍺⍺ ⍵}
f  ← 4∘MSELoss.F
(4 MSELoss.DF ⍵),⍺ (f _D)¨⍵
}"
           input dx))

(defun verify-loss-convergence-series (&key (input 3) (series (april "0.1*⍳5")))
  "Evaluate (verify-loss-convergence) for a series of dx values to illustrate their convergence on the output of the derivative function."
  (verify-loss-convergence input series))

(defun verify-network-output-loss (&key (shape #(2 5 3)) (input 0) (target 0))
  "Check the output of the MSELoss function called on the output of a forward pass with a neural network having optionally specified shape, input and target values."
  (april-c (with (:space fnn-demo-space))
           "{
inp    ← ⍪(⊃ ⍵)⍴⊃ ⍺
target ← ⍪(⊃⌽⍵)⍴⊃⌽⍺
net    ← InitNetwork ⍵
labels ← ⍪'Target' 'Output'

{⎕←labels,⊖⍉⍵,target ⋄ ⎕←'Loss: ',⍕target MSELoss.F ⍵} ⊃⌽net (LeakyReLU.F _ForwardPass) inp
'Target/output loss calculated.'
}"
           shape (vector input target)))

;; initialize dynamic function assignments for use within _Train
;; TODO: this can be better architected
(april (with (:space fnn-demo-space))
       "
 fAct  ← LeakyReLU.F
dfAct  ← LeakyReLU.DF
 fLoss ←   MSELoss.F
dfLoss ←   MSELoss.DF
")

#|
-- Function --
Network Training

This function performs a training iteration on a neural network.
|#

(april (with (:space fnn-demo-space))
       "
_Train ← {
  (Ws bs) ← ⍶
  xs  ← ⍶ (fAct _ForwardPass) ⍵
  dWs ← dbs ← ⍬ ⍝ is the ⍬ character explained in the tutorial?
  dx  ← ⍺ dfLoss ⊃⌽xs
  ⊢⊢(⊢⊣⌽¯1↓xs){
    W ← ⍵⊃⌽Ws ⋄ b ← ⍵⊃⌽bs ⋄ x ← ⍺
    
    dbs ,← ⊂dx×dfAct b+W+.×x
    dx  ⊢← (⍉W)+.×⊃⌽dbs
    dWs ,← ⊂(⊃⌽dbs)+.×⍉x
  }¨⊢⊣⍳≢Ws
  (0.001×⌽dWs) (0.001×⌽dbs)
}
")

#|
∘○ To Verify ○∘
Trained Network States

Evaluate (verify-training-output) to either 1. initialize a neural network if none is stored or 2. perform an iteration of training upon the stored neural network. You can start again with a fresh network by evaluating (verify-training-output-restart). As with (verify-loss-applied), (verify-training-output) can take 3 arguments specifying the shape of the network, its input and its target. 

The input and target values will be reshaped into vectors matching the first and last dimensions of the network, respectively. Changing the shape, input or target values when a network exists will cause the network to be rebuilt with those values applying.
|#

(let ((net-state) (net-shape) (net-input) (net-target)
      (derived-input) (derived-target) (iteration 0))
  (defun verify-training-output-restart ()
    "Clear the network state of the training output test function."
    (setf net-state nil))
  (defun verify-training-output (&optional (shape #(2 5 3)) (input 0) (target 0))
    "Get the output of a training iteration upon a neural network with an optionally specified shape, input and target."
    (unless (not (equalp shape net-shape))
      (setf net-shape shape
            net-state nil))
    (unless (equalp input net-input)
      (setf net-input input
            derived-input (april-c  "{⍪⍺⍴⍨⊃ ⍵}" net-shape input)
            net-state nil))
    (unless (equalp target net-target)
      (setf net-target target
            derived-target (april-c "{⍪⍺⍴⍨⊃⌽⍵}" net-shape target)
            net-state nil))
    ;; (print (list :ns net-state shape net-shape input net-input target net-target))
    (if net-state
        (setf net-state (april (with (:space fnn-demo-space)
                                     (:state :in ((net net-state) (target derived-target)
                                                  (inp derived-input))))
                               "target (net _Train) inp")
              iteration (1+ iteration))
        (setf net-state (april-c (with (:space fnn-demo-space)) "InitNetwork" net-shape)
              iteration 0))
    (april-c (with (:space fnn-demo-space))
             "{⎕←display ⍵ ⋄ 0=⍺ : 'Network initialized!' ⋄ 'Training iteration: ',⍕⍺}"
             net-state iteration)))

;; ;; TODO: this causes a bug above, returns nil - why?
;; (april-c (with (:space fnn-demo-space))
;;          "{ (inp target) ← ⍺ ⋄ target (⍵ _Train) inp }"
;;          net-state (vector derived-input derived-target))

#|
== MNIST Digit Image Recognition Test Case ==
The forward-feeding neural network model is to be tested against the MNIST database of handwritten digits. This dataset is made up of four .idx files which are currently available in GZipped format at these URLs:

https://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz
https://yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz
https://yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz
https://yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz

The files must be downloaded and unzipped inside the input/ directory located inside the same directory as this source file.

The following functions implement tools for importing the MNIST data into arrays that may be processed using April and the neural network modeled above.
|#

;; binary format for .idx files
(defbinary idx-file (:byte-order :big-endian)
  (empty 0 :type 16)
  (type 0 :type 8)
  (rank 0 :type 8)
  (dimensions #() :type (simple-array (unsigned-byte 32) (rank)))
  (data #() :type (eval (case type (#x08 `(simple-array (unsigned-byte 8) (,(reduce #'* dimensions))))
                              (#x09 `(simple-array (signed-byte 8) (,(reduce #'* dimensions))))
                              (#x0b `(simple-array (signed-byte 16) (,(reduce #'* dimensions))))
                              (#x0c `(simple-array (signed-byte 32) (,(reduce #'* dimensions))))
                              (#x0d `(simple-array single-float (,(reduce #'* dimensions))))
                              (#x0e `(simple-array double-float (,(reduce #'* dimensions))))))))

(defun idx-file-to-array (file-path)
  "Load the contents of an .idx file into an array."
  (with-open-binary-file (in-raw file-path :direction :input)
    (with-wrapped-in-bit-stream (in in-raw :byte-order :big-endian)
      (let ((idx-input (read-binary 'idx-file in)))
        (if (= 1 (slot-value idx-input 'rank))
            (slot-value idx-input 'data)
            (make-array (loop :for d :across (slot-value idx-input 'dimensions) :collect d)
                        :element-type (array-element-type (slot-value idx-input 'data))
                        :displaced-to (slot-value idx-input 'data)))))))

(let ((training-data) (training-labels) (test-data) (test-labels))
  (defun load-idx-files ()
    "Load data from .idx files in the input/ directory into four variables."
    (setf training-data (idx-file-to-array (asdf:system-relative-pathname
                                            *package-symbol* "input/train-images.idx3-ubyte"))
          training-labels (idx-file-to-array (asdf:system-relative-pathname
                                              *package-symbol* "input/train-labels.idx1-ubyte"))
          test-data (idx-file-to-array (asdf:system-relative-pathname
                                        *package-symbol* "input/t10k-images.idx3-ubyte"))
          test-labels (idx-file-to-array (asdf:system-relative-pathname
                                          *package-symbol* "input/t10k-labels.idx1-ubyte")))
    "MNIST digit image data loaded.")
  ;; these functions fetch the input data
  (defun get-training-data () training-data)
  (defun get-training-labels () training-labels)
  (defun get-test-data () test-data)
  (defun get-test-labels () test-labels))

#|
○∘ To Demonstrate ∘○

Evaluate (load-digit-training-data) followed by (build-digit-network) to load the MNIST training data and build a neural network. Then, run (train-digit-network) to train the network. Optionally, a count may be passed to (train-digit-network) if you wish to train the network on a limited subset of the MNIST training data rather than training on all 60,000 images.

The functions (get-net-state) (get-data-segment) and (set-data-segment) are utility functions which may be useful in analyzing the data passing through the network.


|#

(let ((net-shape) (net-state) (image-size 0) (training-data) (training-labels)
      ;; tabled vectors representing the target states for the 10 digits
      (segment-dims) (tdata-segment) (target-arrays (april "(⊂3⎕DT 10 1↑1)⊖¨⍨-⎕IO-⍨⍳10")))
  (defun load-digit-training-data ()
    "Load the training dataset of handwritten digit images from MNIST."
    (unless training-data
      (unless (get-training-data)
        (format t "Loading MNIST training images...~%")
        (load-idx-files))
      (setf training-data (get-training-data)
            training-labels (get-training-labels)
            image-size (reduce #'* (rest (array-dimensions training-data)))
            segment-dims (list image-size 1)
            ;; the digit image frames are raveled into 784-element tabled vectors for input
            tdata-segment (make-array segment-dims
                                      :element-type (array-element-type training-data)
                                      :displaced-to training-data :displaced-index-offset 0)))
    (april-c "{'Loaded ',(⍕⍴⍵),' MNIST training images with labels.'}" training-labels))

  (defun build-digit-network (&optional (intermediate-shape #(16 16)))
    "Generate a neural network with an optionally specified intermediate state (not determined by the input or output shapes)."
    (setf net-shape (april-c "{⊃,/⍺ ⍵ 10}" intermediate-shape image-size)
          net-state (april-c (with (:space fnn-demo-space)) "InitNetwork" net-shape))
    (april-c "{'Built MNIST digit recognition network with shape ',(⍕⍵),'.'}" net-shape))

  (defun get-net-state ()
    "Retrieve the state of the neural network."
    net-state)

  (defun set-net-state (data)
    "Set the state of the neural network."
    (setf net-state data))
  
  (defun get-data-segment ()
    "Retrive the currently designated digit image in the form of a tabled integer vector."
    tdata-segment)

  (defun set-data-segment (index)
    "Set the designated digit image."
    (adjust-array tdata-segment segment-dims
                  :displaced-to training-data
                  :displaced-index-offset (* index image-size)))

  (defun verify-mnist-image-pass ()
    "See the output of a forward pass with the currently designated digit within the MNIST training image set."
    (build-digit-network)
    (april-c (with (:space fnn-demo-space))
             "{⎕←display 1↓⍵ (LeakyReLU.F _ForwardPass) ⍺ ⋄ 'Printed calculated bias vectors.'}"
             net-state (get-data-segment)))

  (defun train-digit-network (&optional count)
    "Train the created neural net on the set of MNIST images, either up to an optionally specified count or processing all 60,000 images."
    (let ((notice-interval 200)
          (count (or (and count (min count (length training-labels))
                     (length training-labels)))))
      ;; (print (list :dt image-size segment-dims (type-of training-data) (type-of tdata-segment)))
      ;; (print (list :ns net-state shape net-shape input net-input target net-target))
      (format t "Training network. Each ⍠ printed means ~a iterations complete.~%" notice-interval)
      (dotimes (index count)
        (let ((label (aref training-labels index)))
          (set-data-segment index)
          ;; (print (list :td (aref target-arrays label)))
          ;; (april-c "{⎕←10↑1500⌽,1 1⊃⍵}" net-state)
          (set-net-state (april (with (:space fnn-demo-space)
                                      (:state :in ((net (get-net-state))
                                                   (target (aref target-arrays label))
                                                   (inp (get-data-segment)))))
                                "target (net _Train) inp"))
          (when (zerop (mod (1+ index) notice-interval))
            (princ "⍠ "))
          ;; (april-c "{⎕←10↑1500⌽,1 1⊃⍵}" net-state)
          ;; (april-c "{⎕←+/¯0.0=,1 1⊃⍵}" net-state)
          ))
      (format nil "Completed ~a training iterations." count))))
