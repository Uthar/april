;;;; varray.lisp

(in-package #:varray)

(defclass varray ()
  ((%shape :accessor varray-shape
           :initform nil
           :initarg :shape
           :documentation "The array's shape - typically populated by a (shape-of) method."))
  (:documentation "Virtual array - the ancestor class for all virtual array objects."))

(defun varrayp (item)
  (typep item 'varray))

;; to get the element type of an array
(defgeneric etype-of (array))

(defgeneric prototype-of (array))

;; to get the shape of an array
(defgeneric shape-of (array))

;; to get an indexing function for an array
(defgeneric indexer-of (array))

;; to render an array into memory
(defgeneric render (array))

;; the default element type is t
(defmethod etype-of ((item t))
  (assign-element-type item))

;; the default element type is t
(defmethod etype-of ((array array))
  (array-element-type array))

;; the default element type is t
(defmethod etype-of ((varray varray))
  t)

;; the default element type is t
(defmethod prototype-of ((item t))
  (apl-array-prototype item))

;; the default element type is t
(defmethod prototype-of ((varray varray))
  0)

;; by default, get the array's stored shape
(defmethod shape-of ((_ t))
  (declare (ignore _))
  nil)

;; by default, get the array's stored shape
(defmethod shape-of ((array array))
  (array-dimensions array))

;; by default, get the array's stored shape
(defmethod shape-of ((varray varray))
  (varray-shape varray))

(defmethod indexer-of ((item t))
  item)

(defmethod indexer-of ((array array))
  (if (= 0 (array-rank array))
      array (lambda (index) (row-major-aref array index))))

(defmethod render ((item t))
  item)

(defmethod render ((varray varray))
  (let ((output-shape (shape-of varray))
        (indexer (indexer-of varray)))
    (if output-shape
        (let ((output (make-array (shape-of varray) :element-type (etype-of varray))))
          (dotimes (i (array-total-size output))
            (setf (row-major-aref output i)
                  (funcall indexer i)))
          output)
        (funcall indexer 1))))

(defmacro get-or-assign-shape (object form)
  `(or (varray-shape ,object) (setf (varray-shape ,object) ,form)))

(defclass varray-primal (varray) nil
  (:documentation "A primal array: a virtual array defined wholly by its parameters, not derived from another array."))

(defclass varray-derived (varray)
  ((%base :accessor vader-base
          :initform nil
          :initarg :base
          :documentation "The array from which the array is derived."))
  (:documentation "A derived array: virtual array derived from another array."))

;; the default shape of a derived array is the same as its base array
(defmethod etype-of ((varray varray-derived))
  (if (arrayp (vader-base varray))
      (array-element-type (vader-base varray))
      (etype-of (vader-base varray))))

;; the default shape of a derived array is the same as its base array
(defmethod prototype-of ((varray varray-derived))
  (if (varrayp (vader-base varray))
      (apl-array-prototype (funcall (indexer-of (vader-base varray)) 0))
      (prototype-of (vader-base varray))))

(defmethod shape-of ((varray varray-derived))
  "The default shape of a derived array is the same as the original array."
  (get-or-assign-shape varray (shape-of (vader-base varray))))

;; (defmacro index-base-array-with (varray this-indexer)
;;   (let ((x (gensym)) (y (gensym)))
;;     `(lambda (,x)
;;        (funcall (if (typep (vader-base ,varray) 'varray)
;;                     (indexer-of (vader-base ,varray))
;;                     (lambda (,y) (row-major-aref (vader-base ,varray) ,y)))
;;                 (funcall ,this-indexer ,x)))))

(defclass vvector-integer-progression (varray-primal)
  ((%number :accessor vvip-number
            :initform 1
            :initarg :number
            :documentation "The number of values.")
   (%origin :accessor vvip-origin
            :initform 0
            :initarg :origin
            :documentation "The origin point - by default, the index origin.")
   (%factor :accessor vvip-factor
            :initform 1
            :initarg :factor
            :documentation "Factor of values.")
   (%repeat :accessor vvip-repeat
            :initform 1
            :initarg :repeat
            :documentation "Instances of each value."))
  (:documentation "Integer progression vector - a series of numeric values generated by [⍳ index]."))

(defmethod etype-of ((vvector vvector-integer-progression))
  (if (floatp (vvip-factor vvector))
      'double-float (list 'integer (min 0 (vvip-origin vvector))
                          (+ (vvip-origin vvector)
                             (first (shape-of vvector))))))

(defmethod prototype-of ((vvector vvector-integer-progression))
  (declare (ignore vvector))
  0)

;; the shape of an IP vector is its number times its repetition
(defmethod shape-of ((vvector vvector-integer-progression))
  (get-or-assign-shape vvector (list (* (vvip-number vvector)
                                        (vvip-repeat vvector)))))

;; the IP vector's parameters are used to index its contents
(defmethod indexer-of ((vvector vvector-integer-progression))
  (lambda (index)
    (if (< -1 index (vvip-number vvector))
        (* (+ (floor index (vvip-repeat vvector))
              (vvip-origin vvector))
           (vvip-factor vvector)))))

(defclass vad-on-axis ()
  ((%axis :accessor vadx-axis
          :initform :last
          :initarg :axis
          :documentation "The axis along which to transform."))
  (:documentation "Superclass of array transformations occuring along an axis."))

(defclass vad-with-argument ()
  ((%argument :accessor vads-argument
              :initform :last
              :initarg :argument
              :documentation "Parameters passed to an array transformation as an argument."))
  (:documentation "Superclass of array transformations occuring along an axis."))

(defclass vad-invertable ()
  ((%inverse :accessor vads-inverse
             :initform :last
             :initarg :inverse
             :documentation "Parameters passed to an array transformation as an argument."))
  (:documentation "Superclass of array transformations that have an inverse variant as [↓ drop] is to [↑ take]."))

;; a reshaped array as with the [⍴ shape] function
(defclass vader-reshape (varray-derived vad-with-argument) nil)

(defmethod shape-of ((varray vader-reshape))
  "The shape of a reshaped array is simply its argument."
  (vads-argument varray))

;; a sectioned array as from the [↑ take] or [↓ drop] functions
(defclass vader-section (varray-derived vad-on-axis vad-with-argument)
  ((index-origin :accessor vasec-io
                 :initform 1
                 :initarg :index-origin)
   (inverse :accessor vasec-inverse
            :initform nil
            :initarg :inverse)))

(defmethod prototype-of ((varray vader-section))
  (let ((indexer (indexer-of (vader-base varray))))
    ;; TODO: remove-disclose when [⍴ shape] is virtually implemented
    (aplesque::make-empty-array (if (not (functionp indexer))
                                    (disclose indexer) ;; ←← remove
                                    (funcall (indexer-of (vader-base varray)) 0)))))

(defmethod shape-of ((varray vader-section))
  "The shape of a sectioned array is the parameters (if not inverse, as for [↑ take]) or the difference between the parameters and the shape of the original array (if inverse, as for [↓ drop])."
  (get-or-assign-shape
   varray
   (let* ((arg-shape (shape-of (vads-argument varray)))
          (arg-indexer (indexer-of (vads-argument varray)))
          (base-shape (copy-list (shape-of (vader-base varray))))
          (is-inverse (vasec-inverse varray))
          (iorigin (vasec-io varray))
          (axis (vadx-axis varray))
          (pre-shape (if t ; (vasec-inverse varray)
                         ;; (loop :for b :below (max (length base-shape)
                         ;;                          (if (not arg-shape)
                         ;;                              1 (first arg-shape)))
                         ;;       :for d :from 0
                         ;;       :collect (let ((argix (if (not (functionp arg-indexer))
                         ;;                                 (if (= 0 d) arg-indexer 0)
                         ;;                                 (or (funcall arg-indexer d)
                         ;;                                     0))))
                         ;;                  (- b (abs argix))))
                         (loop :for b :below (max (length base-shape)
                                                  (if (not arg-shape)
                                                      1 (first arg-shape)))
                               :collect (or (nth b base-shape) 1)))))

     ;; (print (list :pr pre-shape))

     (if (vectorp axis)
         (loop :for x :across axis :for ix :from 0
               :do (setf (nth (- x iorigin) pre-shape)
                         (if is-inverse (- (nth (- x iorigin) pre-shape)
                                           (abs (funcall arg-indexer ix)))
                             (abs (funcall arg-indexer ix)))))
         (if (eq :last axis)
             (if (functionp arg-indexer)
                 (loop :for a :below (first arg-shape) :for ix :from 0
                       :do (setf (nth ix pre-shape)
                                 (if is-inverse (max 0 (- (nth ix pre-shape)
                                                          (abs (funcall arg-indexer a))))
                                     (abs (funcall arg-indexer a)))))
                 (setf (first pre-shape)
                       (if is-inverse (max 0 (- (first pre-shape) (abs arg-indexer)))
                           (abs arg-indexer))))
             (setf (nth (- axis iorigin) pre-shape)
                   (if is-inverse (max 0 (- (nth (- axis iorigin) pre-shape)
                                            (abs arg-indexer)))
                       (abs arg-indexer)))))

     ;; (print (list :aa axis pre-shape))
     
     pre-shape)))

(defmethod indexer-of ((varray vader-section))
  "Indexer for a sectioned array."
  (lambda (index)
    (let* ((base-indexer (indexer-of (vader-base varray)))
           (iorigin (vasec-io varray))
           (axis (vadx-axis varray))
           (arg-shape (shape-of (vads-argument varray)))
           (arg-indexer (indexer-of (vads-argument varray)))
           (is-inverse (vasec-inverse varray))
           (out-dims (if is-inverse (make-array (length (shape-of varray))
                                                :initial-element 0)
                         (coerce (shape-of varray) 'vector))))

          (if (vectorp axis)
              (loop :for x :across axis :for ix :from 0
                    :do (setf (aref out-dims (- x iorigin))
                              (funcall arg-indexer ix)))
              (if (eq :last axis)
                  (if (functionp arg-indexer)
                      (loop :for a :below (first arg-shape) :for ix :from 0
                            :do (setf (aref out-dims ix)
                                      (funcall arg-indexer a)))
                      (setf (aref out-dims 0) arg-indexer))
                  (setf (aref out-dims (- axis iorigin))
                        arg-indexer)))

      ;; (print (list :oo out-dims))
      
      (if (not (functionp base-indexer))
          (if (= 0 index) (disclose base-indexer)
              (prototype-of (vader-base varray)))
          (let ((indexed (funcall (indexer-section
                                   (vasec-inverse varray)
                                   (shape-of (vader-base varray))
                                   out-dims nil)
                                  index)))
            (if indexed (funcall base-indexer indexed)
                (prototype-of (vader-base varray))))))))

(defclass vader-meta-scalar-pass (varray-derived) nil)

(defclass vader-turn (varray-derived vad-on-axis vad-with-argument)
  ((%index-origin :accessor vaturn-io
                  :initform 1
                  :initarg :index-origin
                  :documentation "The index origin."))
  (:documentation "A rotated array as from the [⌽ rotate] function."))

(defun arg-process (argument)
  (if (or (listp argument) (numberp argument))
      argument (if (varrayp argument)
                   (render argument) ;; TODO: eliminate forced render here
                   
                   ;(if (vectorp argument)
                   ;    (coerce argument 'list)
                   (if (arrayp argument)
                       argument))))

(defmethod indexer-of ((varray vader-turn))
  "Indexer for a rotated or flipped array."
  (lambda (index)
    (let ((base-indexer (indexer-of (vader-base varray))))
      (if (not (functionp base-indexer))
          base-indexer (funcall base-indexer
                                (funcall (indexer-turn (if (eq :last (vadx-axis varray))
                                                           (1- (length (shape-of varray)))
                                                           (- (vadx-axis varray)
                                                              (vaturn-io varray)))
                                                       (shape-of varray)
                                                       (arg-process (vads-argument varray)))
                                         index))))))

;; a permuted array as from the [⍉ permute] function
(defclass vader-permute (varray-derived)
  ((argument :accessor vapermute-argument
             :initform nil
             :initarg :argument)))

;; (1 2 3) (2 3 4)∘.⌽[1]⊂3 3⍴⍳9 NOT IN DYALOG?
