;;;; varray.lisp

(in-package #:varray)

;; virtual array - the ancestor class
(defclass varray ()
  ((shape :accessor varray-shape ; the array's shape - typically populated by a (shape-of) method
          :initform nil
          :initarg :shape)))

(defun varrayp (item)
  (typep item 'varray))

;; to get the element type of an array
(defgeneric etype-of (varray))

;; to get the shape of an array
(defgeneric shape-of (varray))

;; to get an indexing function for an array
(defgeneric indexer-of (varray))

;; to render an array into memory
(defgeneric render (varray))

;; the default element type is t
(defmethod etype-of ((varray varray))
  t)

;; by default, get the array's stored shape
(defmethod shape-of ((varray varray))
  (varray-shape varray))

(defmethod render ((varray varray))
  (let ((output-shape (shape-of varray))
        (indexer (indexer-of varray)))
    (if output-shape
        (let ((output (make-array (shape-of varray) :element-type (etype-of varray))))
          (dotimes (i (array-total-size output))
            (setf (row-major-aref output i)
                  (funcall indexer i)))
          output)
        (funcall indexer 1))))
    
;; primal array - a virtual array defined wholly by its parameters, not derived from another array
(defclass varray-primal (varray) nil)

;; derived array - a virtual array derived from another array
(defclass varray-derived (varray)
  ((base :accessor vader-base ; the array from which the array is derived
         :initform nil
         :initarg :base)))

(defmethod base-shape-of ((varray varray-derived))
  (if (and (not (arrayp (vader-base varray)))
           (not (varrayp (vader-base varray))))
      nil
      (funcall (if (arrayp (vader-base varray))
                   #'array-dimensions #'shape-of)
               (vader-base varray))))

;; the default shape of a derived array is the same as its base array
(defmethod etype-of ((varray varray-derived))
  (if (arrayp (vader-base varray))
      (array-element-type (vader-base varray))
      (etype-of (vader-base varray))))

;; the default shape of a derived array is the same as its base array
;; (defmethod shape-of ((varray varray-derived))
;;   (base-shape-of varray))

(defmacro get-or-assign-shape (object form)
  `(or (call-next-method) (setf (varray-shape ,object) ,form)))

(defmacro index-base-array-with (varray this-indexer)
  (let ((x (gensym)) (y (gensym)))
    `(lambda (,x)
       (funcall (if (typep (vader-base ,varray) 'varray)
                    (indexer-of (vader-base ,varray))
                    (lambda (,y) (row-major-aref (vader-base ,varray) ,y)))
                (funcall ,this-indexer ,x)))))

;; integer progression vector - a series of numeric values generated by [⍳ index]
(defclass vvector-integer-progression (varray-primal)
  ((number :accessor vvip-number ; the number of values
           :initform 1
           :initarg :number)
   (origin :accessor vvip-origin ; the origin point - by default, the index origin
           :initform 0
           :initarg :origin)
   (factor :accessor vvip-factor ; factor of values
           :initform 1
           :initarg :factor)
   (repeat :accessor vvip-repeat ; instances of each value
           :initform 1
           :initarg :repeat)))

(defmethod etype-of ((vvector vvector-integer-progression))
  (if (floatp (vvip-factor vvector))
      'double-float (list 'integer (min 0 (vvip-origin vvector))
                          (+ (vvip-origin vvector)
                             (first (shape-of vvector))))))

;; the shape of an IP vector is its number times its repetition
(defmethod shape-of ((vvector vvector-integer-progression))
  (get-or-assign-shape vvector (list (* (vvip-number vvector)
                                        (vvip-repeat vvector)))))

;; the IP vector's parameters are used to index its contents
(defmethod indexer-of ((vvector vvector-integer-progression))
  (lambda (index)
    (if (< -1 index (vvip-number vvector))
        (* (+ (floor index (vvip-repeat vvector))
              (vvip-origin vvector))
           (vvip-factor vvector)))))

;; a reshaped array as with the [⍴ shape] function
(defclass vader-reshape (varray-derived)
  ((argument :accessor vareshape-argument
             :initform nil
             :initarg :argument)))

(defmethod shape-of ((varray vader-reshape))
  "The shape of a reshaped array is simply its argument."
  (vareshape-argument varray))

;; a sectioned array as from the [↑ take] or [↓ drop] functions
(defclass vader-section (varray-derived)
  ((argument :accessor vasec-argument
             :initform nil
             :initarg :argument)
   (inverse :accessor vasec-inverse
            :initform nil
            :initarg :inverse)
   (axis :accessor vasec-axis
         :initform :last
         :initarg :axis)))

;; (defmethod shape-of ((varray vader-section))
;;   "The shape of a sectioned array is the parameters (if not inverse, as for [↑ take]) or the difference between the parameters and the shape of the original array (if inverse, as for [↓ drop])."
;;   (get-or-assign-shape varray (if (vasec-inverse varray)
;;                                   (with-base-shape base-shape varray
;;                                     (loop :for b :in base-shape :for d :in (vasec-argument varray)
;;                                           :collect (- b (abs d))))
;;                                   (vasec-argument varray))))

(defclass vader-meta-scalar-pass (varray-derived) nil)

;; (defmethod indexer-of ())

;; a rotated array as from the [⌽ rotate] function
(defclass vader-turn (varray-derived) ; vader-meta-scalar-pass)
  ((argument :accessor vaturn-argument
             :initform nil
             :initarg :argument)
   (index-origin :accessor vaturn-io
                 :initform 1
                 :initarg :index-origin)
   (axis :accessor vaturn-axis
         :initform :last
         :initarg :axis)))

;; (defmethod shape-of ((varray vader-turn))
;;   "The shape of a rotated array is the same as the original array."
;;   (get-or-assign-shape varray (shape-of (vader-base varray))))

(defmethod shape-of ((varray vader-turn))
  "The shape of a rotated array is the same as the original array."
  (get-or-assign-shape varray (base-shape-of varray)))

(defun arg-process (argument)
  (if (or (listp argument) (numberp argument))
      argument (if (varrayp argument)
                   (render argument)
                   ;(if (vectorp argument)
                   ;    (coerce argument 'list)
                   (if (arrayp argument)
                       argument))))

(defmethod indexer-of ((varray vader-turn))
  "Indexer for a rotated or flipped array."
  (lambda (x)
    (if (and (not (arrayp (vader-base varray)))
             (not (varrayp (vader-base varray))))
        (vader-base varray)
        (funcall (if (varrayp (vader-base varray))
                     (indexer-of (vader-base varray))
                     (if (and (arrayp (vader-base varray))
                              (< 0 (array-rank (vader-base varray))))
                         (lambda (y) (row-major-aref (vader-base varray) y))
                         (vader-base varray)))
                 (funcall (indexer-turn (if (eq :last (vaturn-axis varray))
                                            (1- (length (shape-of varray)))
                                            (- (vaturn-axis varray)
                                               (vaturn-io varray)))
                                        (shape-of varray)
                                        (arg-process (vaturn-argument varray)))
                          x)))))

;; a permuted array as from the [⍉ permute] function
(defclass vader-permute (varray-derived)
  ((argument :accessor vapermute-argument
             :initform nil
             :initarg :argument)))

;; (1 2 3) (2 3 4)∘.⌽[1]⊂3 3⍴⍳9 NOT IN DYALOG?
;; y←⍳12 ⋄ (5○⍨-y)=y∘○⍣¯1⊢5
;; mscan ⍳10
